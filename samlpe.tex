\documentclass[a4paper,10pt]{article}
\usepackage{CJKutf8}
\linespread{1.6}
\usepackage{diagbox}
\setlength{\parskip}{0.5\baselineskip}
\usepackage{bm}
\usepackage{color}
\usepackage{xcolor}
\definecolor{keywordcolor}{rgb}{0.8,0.1,0.5}
\usepackage{listings}
%\lstset{breaklines}				%这条命令可以让LaTeX自动将长的代码行换行排版
\lstset{extendedchars=false}		%这一条命令可以解决代码跨页时，章节标题，页眉等汉字不显示的问题
\lstset{language=C++, 			%用于设置语言为C++
	keywordstyle=\color{keywordcolor} \bfseries, 
	identifierstyle=,
	basicstyle=\ttfamily, 
	commentstyle=\color{blue} \textit,
	stringstyle=\ttfamily, 
	showstringspaces=false,
	frame=single, 				%边框
	numbers=left
}
\renewcommand{\abstractname}{摘要} 
\title{DP入门\&\&记忆化搜索}
\author{哈尔滨工程大学ACM集训队}
\begin{document}
\begin{CJK}{UTF8}{gbsn}
\maketitle
\section{动态规划}
DP：$Dynamic\ Programming$的缩写，中文意思动态规划。在讲解这个概念之前先来看一个例子，让大家体会下什么是动态规划。\par
举一个通俗的例子（当然也很经典），简单$0-1$（取或不取）背包问题：\begin{CJK}{UTF8}{gkai}假设现在你有一个容量为V的背包和一堆石头，每个石头都有一个体积$v_i$和价值$w_i$,你需要向背包里面装一些石头使这些石头的价值之和最大，问你这个最大价值是多少？\end{CJK}\par
你可能会想到首先挑价值最大的装，例如：$V = 20$，有$3$个石头（以下石头都以\bm{$[v_i,w_i]$}形式表示），体积和价值分别是$[18,22],[15,30],[9,13]$,这时你选择一个价值最大的$[18,22]$，并且发现这就是最终的最大价值，因为这个包只能装一个石头，这个方法奏效了。\par
继续看 :$ V = 20$，有3个石头，体积和价值分别是$[10,22],[15,30],[9,13]$,仍然首先选价值最大的？那么你得到的答案就是30，因为当你装完这个石头（$[15,30]$）后其他的石头再也无法装入！事实上很显然这个答案应该是$22 + 13 = 35$，选择$[10,22],[9,13]$，$10 + 9 = 19 < 20$。所以这个思路是错的，因为受背包本身容量的影响。\par
那么优先选择“性价比”($w_i/v_i$)最大的？容易验证这也是错的，例如：$V = 10$，两个石头体积和价值分别是$[2,8],[5,10]$就是反例。\par
\textbf{上面两种思路之所以错是因为他们都是贪心思想。显然对于背包问题如果我们一味的贪心很可能使我们在贪心的过程中丢失全局最优解。因为在后来的选择中我们很可能需要去调整前面的决策方案以使我们达到全局的最优解。}\par
因此，我们需要设一种状态，\textbf{它表示并记录之前我们的决策方案，以便我们需要时去使用它。}\par
\textbf{定义：\bm{$dp[i][j]$}表示背包容量为$i$且在前$j$个石头中选取时的最大价值}。
显然,根据定义如果背包容量为$v$，石头个数为$n$，\textbf{最后答案就是\bm{$dp[v][n]$}}。\par
那么我们如何来得到这个状态呢？换句话说就是\textbf{这个状态可以由哪些状态转移而来？}考虑对于任意一个石头我们有选或不选两种决策，因此取这两者中最大的即可！状态转移方程就是：\par
\begin{center}
$\bm{dp[i][j] = max(dp[i][j-1],dp[i-v[j]][j-1] + w[j])}$
\end{center}\par
\textbf{其中\bm{$dp[i][j-1]$}表示不选第$j$个石头，\bm{$dp[i-v[j]][j-1] + w[j]$}表示选择第$j$个石头。}\footnote{注：$0-1$背包有一维数组的解法，大家课后可以自己看，懂得二维的一维的自然就明白了，在此略过。}
\begin{lstlisting}
//C++ code for this problem
const int MAXN = ONE_CONST_VALUE;
int V,v[MAXN],w[MAXN],dp[MAXN][MAXN] = {0};
for(int i = 1;i <= V;i ++){
  for(int j = 1;j <= n;j ++){
    if(i < v[j]){
      dp[i][j] = dp[i][j-1];
      continue;    
    }
    dp[i][j] = max(dp[i][j-1],dp[i-v[j]][j-1] + w[j]);	
  }
}
\end{lstlisting}
容易看出，算法时间复杂度为\bm{$O(V*n)$}\newpage
下面给一组数据来模拟一下，看看这个算法是怎么工作的\par
\bm{$V = 15,\ 4$}个石头:分别为\bm{$[3,4],\ [5,8],\ [10,10],\ [6,9]$}\par
\begin{center}
    \begin{tabular}{| l | l | l | l | l | l | l | l | l | l  | l | l | l | l | l | l | p{13cm} |}
    \hline
    \diagbox{$n$}{$v$} & 1 & 2 & 3  & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15\\ \hline
    1 & 0 & 0 & 4 & 4 & 4 & 4 & 4 & 4 & 4 & 4 & 4 & 4 & 4 & 4 & 4 \\ \hline
    2 & 0 & 0 & 4 & 4 & 8 & 8 & 8 & 12 & 12 & 12 & 12 & 12 & 12 & 12 & 12 \\ \hline
    3 & 0 & 0 & 4 & 4 & 8 & 8 & 8 & 12 & 12 & 12 & 12 & 12 & 14 & 14 & 18 \\ \hline
    4 & 0 & 0 & 4 & 4 & 8 & 9 & 9 & 12 & 13 & 13 & 17 & 17 & 17 & 21 & 21 \\ \hline
    \end{tabular}
\end{center}
\subsection{概念}
动态规划：是一种在数学、计算机科学和经济学中使用的，\textbf{通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。}\par
\subsection{性质}
\ \ \ \ \  \textbf{$1.$最优子结构:}如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。\par
\ \textbf{$2.$子问题重叠:}子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。\par
再给大家举个例子，加深下印象。\begin{CJK}{UTF8}{gkai}给定一个初始序列，$X = \{a_1,a_2,a_3,a_4,...,a_n\},$求出$X$的一段连续子序列，使得这段子序列的和最大,求出这个最大和。例如序列$X = \{1,2,3,-10,5,6\},$那么$\{1,2,3\},\{2,3,-10\},\{5,6\}$都是$X$的子序列,而$\{1,3\},\{2,5\}$不是。在$X$的所有连续子序列中$\{5,6\}$的和最大。\end{CJK}\par\newpage
考虑不管最终如何选择，\textbf{目标序列都会以序列$X$中的某一个元素结尾}，这是显然的。因此如果我们知道了以$X$中每个元素结尾的连续子序列的最大和时，我们就可以以\bm{$O(n)$}的时间复杂度从左到右扫描一遍整个序列得到最大值。\par
分析到这，状态的设置就很简单了。\textbf{设$dp[i]$表示以元素$a_i$结尾的连续子序列的最大和。}状态转移方程怎么写？\par
\begin{center}
\bm{$dp[i] = max(a[i],a[i] + dp[i-1])$}\par
\end{center}
上述方程的意思是，\textbf{\bm{$dp[i]$}必须选择\bm{$a_i$}(根据定义)，至于选不选\bm{$dp[i-1]$}需要看它是不是大于\bm{$0$}。}\par
\begin{lstlisting}
//C++ code for this problem
const int MAXN = ONE_CONST_VALUE;
int dp[MAXN],ans = -0x7fffffff;
dp[1] = a[1];  //dp[1] only can choose a[1]
for(int i = 2;i <= n;i ++){
  dp[i] = max(a[i],a[i] + dp[i-1]);
  ans = max(ans,dp[i]);
}
\end{lstlisting}
算法时间复杂度$\bm{O(n)$}\par
\subsection{练习题}
给定两个初始字符序列$X,Y (max(len(X),len(Y)) <= 10^3\ )$,求出$X$,$Y$的最长公共子序列的长度$(LCS)$
\section{记忆化搜索}
有了上面DP的基础知识后，我们开始学习记忆化搜索。记忆化搜索在形式上仍然是搜索的流程。我们知道朴素的搜索算法本身就是一种暴力的解法，通过枚举所有状态来得到解（当然可以通过剪枝来舍去一些无效状态），效率低的原因是因为它没有能够很好地处理重叠的子问题。\textbf{在求解问题的过程中我们可能要去求解若干子问题，然而这些子问题可能又会包含相同的子问题，如果我们只是简单的搜索那么有些子问题就会被我们重复计算很多次}，这无疑造成时间的浪费，因此就产生了记忆化搜索，它采用搜索的形式和动态规划中递推的思想将这两种方法有机地综合在一起，扬长避短，简单实用，在信息学中有着重要的作用。用一个公式简单地说：\textbf{记忆化搜索=搜索的形式+动态规划的思想。}\textbf{记忆化搜索的大致思想是：我们在搜索的过程中把已经被搜索过的状态记录并保存起来，如果在以后的搜索过程中再遇到这个状态就不必再搜索下去，直接用即可。}\par
记忆化搜索的大致流程如下：\par
\begin{lstlisting}
XXX dfs(status){
  if(recursion should over) return ;
  if(status have been searched before) return ;
  record status have been searched;
  dfs(next status);
}
\end{lstlisting}
\bm{$1.$}先看一个最简单的例子：斐波那契数列（so easy ? !），相信大家都写过，一个for循环就解决
\begin{lstlisting}
for(int i = 3;i <= n;i ++)
  fib[i] = fib[i-1] + fib[i-2]
\end{lstlisting}
现在从另一个角度解决这个问题，用递归的方法写一次看看(also so easy ? !)，通过这个例子简单体会下记忆化搜索。\par
\begin{lstlisting}
int dfs(int n){
  if(n == 1 || n == 2) return 1;
  return dfs(n-1) + dfs(n-2);
}
\end{lstlisting}
你知道这样写会有多浪费时间吗？下面是在我的计算机上运行出结果的时间(单位：秒)：
\begin{center}
    \begin{tabular}{| l | l | l | l | l | l | l | l | l  | p{1cm} |}   \hline
    N & 10 & 15 & 20 & 25 & 30 & 35 & 40 & 45 & 46 \\ \hline
    T & 0.0000 &  0.0000 & 0.0000 & 0.0000 & 0.0000 & 0.0600 & 0.6200 & 6.8800 & 16.7400 \\ \hline
    \end{tabular}
\end{center}
\textbf{之所以这么慢是因为我们重复计算了很多的子问题，上述代码中求\bm{$dfs(n)$}的时候首先会去求\bm{$dfs(n-1)$}，程序就跳到下一轮递归，dfs(n-1)算完之后程序会回溯，然后又去计算\bm{$dfs(n-2)$}，显然在求\bm{$dfs(n-1)$}的过程中\bm{$dfs(n-2)$}就已经求出来了，只是我们没有记录和保存它，导致了我们又要重新算一次$\bm{dfs(n-2)}$}，造成了时间的浪费，时间复杂度一下子就被我们提上来了。\par
如果采用记忆化搜索的思想，把被计算过的状态保存下来，那么时间会大大降低:
\begin{lstlisting}
//C++ code for this problem
long long int dp[50] = {0};
long long int dfs(int n){
   if(n == 1 || n == 2) return 1;
   if(dp[n]) return dp[n];
   return dp[n] = dfs(n-1) + dfs(n-2);
}
\end{lstlisting}\par
这样，\textbf{每个状态只被计算一次时间复杂度为\bm{$O(n)$}}，运行时间为：
\begin{center}
    \begin{tabular}{| l | l | l | l | l | l | l | l | l  | p{1cm} |}   \hline
    N & 10 & 15 & 20 & 25 & 30 & 35 & 40 & 45 & 46 \\ \hline
    T & 0.0000 &  0.0000 & 0.0000 & 0.0000 & 0.0000 & 0.0000 & 0.0000 & 0.0000 & 0.0000 \\ \hline
    \end{tabular}
\end{center}
\bm{$2.$}：\begin{CJK}{UTF8}{gkai}Michael喜欢滑雪百这并不奇怪， 因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael想知道载一个区域中最长底滑坡。区域由一个二维数组$mat[R][C]$给出行数$R$和列数$C$($1 <= R,C <= 100$)。数组的每个数字代表点的高度。下面是一个例子:\par
\begin{center}     %开始数学环境
$\left[                 %左括号
  \begin{array}{ccccc}   %该矩阵一共3列，每一列都居中放置
    1 & 2 & 3 & 4 & 5 \\
	16 & 17 & 18 & 19 & 6 \\
    15 & 24 & 25 & 20 & 7 \\
	14 & 23 & 22 & 21 & 8 \\
	13 & 12 & 11 & 10 & 9
  \end{array}
\right]$                 %右括号
\end{center}
一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度减小。在上面的例子中，一条可滑行的滑坡为24-17-16-1。当然25-24-23-...-3-2-1更长。事实上，这是最长的一条。\end{CJK}\par
\textbf{思考：假设我们知道了从某个点$[i,j]$周围的四个点开始滑雪的最大长度\bm{$h_{1m},h_{2m},h_{3m},h_{4m},$}那么我们就可以得到从该点滑雪的最大长度\bm{$h[i][j]_m$}，根据动态规划思想：}\par
\begin{center}
\bm{$h[i][j]_m = max(h[i][j]_m,h_{km} + 1)\ \ \ \ \ \  (1 <= k <= 4) $}\par
\textbf{如果该点高度大于第$k$个点的高度}
\end{center}
\textbf{因此采用记忆化搜索，对于每个没有被搜索过的点进行搜索，在搜索的过程中如果发现某个点已被搜索就不要再向下搜索，直接返回结果即可。}\newline\\
\bm{$3$}.最后再来看个例子: \begin{CJK}{UTF8}{gkai}对于一个字符串中的重复部分可以进行缩写，例如gogogo可以写成3(go),从6个字符变成5个字符，nowletsgogogoletsgogogoand\\runrunruncould可以写成now2(lets3(go))and3(run).现在问在这个规则下，问给定一个串的最短长度是多少?\end{CJK}
\end{CJK}
\end{document}







