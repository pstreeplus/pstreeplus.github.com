\documentclass[a4paper,10pt]{article}
\usepackage{CJKutf8}
\linespread{1.6}
\usepackage{graphicx} 
\usepackage{diagbox}
\setlength{\parskip}{0.5\baselineskip}
\usepackage{bm}
\usepackage{color}
\usepackage{xcolor}
\usepackage[pdfstartview=FitH]{hyperref}
\definecolor{keywordcolor}{rgb}{0.8,0.1,0.5}
\usepackage{listings}
%\lstset{breaklines}				%这条命令可以让LaTeX自动将长的代码行换行排版
\lstset{extendedchars=false}		%这一条命令可以解决代码跨页时，章节标题，页眉等汉字不显示的问题
\lstset{language=Java, 			%用于设置语言为Java
	keywordstyle=\color{keywordcolor} \bfseries, 
	identifierstyle=,
	basicstyle=\ttfamily, 
	commentstyle=\color{blue} \textit,
	stringstyle=\ttfamily, 
	showstringspaces=false,
	frame=single, 				%边框
	numbers=left
}
\renewcommand{\abstractname}{摘要} 
\title{FileNotFoundException}
\author{20120616 by 吕健侨，朱明辉，程春阳，王志立}
\begin{document}
\begin{CJK}{UTF8}{gbsn}
\maketitle
\begin{abstract}
\begin{CJK}{UTF8}{gkai}\textbf{Java的基本理念是 “结构不佳的代码不能运行”}\par
发现错误的理想时机是在编译阶段，也就是在试图运行程序之前。然而编译时期并不能找出所有错误，余下的问题必须在运行期解决，这就需要错误源能通过某种方式，把错误的信息传给某个接收者,该接收者知道如何正确处理这个问题。
\end{CJK}\par

\end{abstract}
 
\section{Java I/O}\hypertarget{FileOt}{}

\subsection{File类}
	File(文件)类这个名字有一定误导性：我们很可能认为它指代的是文件，实际上却并非如此。\textbf{它既能代表一个特定文件的名称，又能代表一个目录下一组文件的名称。实际上它更像是一个“路径”。}因此曾经有人建议将File类改名为Filepath。\hyperlink{File}{\textbf{查看File类函数}}\par

\hyperlink{testfile}{view sample}\hypertarget{rfile}{}

File能创建，删除，重命名文件或目录，但File不能访问文件内容本身。如果要访问文件内容本身则需要使用输入/输出流。\newpage

\subsection{输入输出流}
\includegraphics{11.jpg}
\begin{CJK}{UTF8}{gkai}{编程语言的I/O类库中常使用流这个抽象的概念，它代表任何有能力产出数据的数据源对象或是有能力接受数据的接受端对象。“流”屏蔽了实际的I/O设备中处理数据的细节。}

\end{CJK}\par

Java类库中的I/O按流向分成输入和输出两个部分，每个部分按处理的单位又分为字节流($8$位)和字符流($16$位)。字节流对应InputStream/OutputStream接口，字符流对应Reader/Writer接口。\par
InputStream 的一个实现类是FileInputStream,OutputStream 的一个实现类是FileOutputStream,同样，FileReader实现了Reader，FileWriter实现了Writer。\par

FileInputStream类使用read()读取数据，FileoutputStream类使用write()写入数据。\newpage
\begin{lstlisting}
int read();
int read(byte [] b);
int read(byte [] b ,int off,int len);
int write();
int write(byte [] b);
int write(byte [] b ,int off,int len);

\end{lstlisting}
\hypertarget{Test}{}
\ \\
例如：使用它们可以完成文件的复制 \ \ \hyperlink{copy}{view code}\hypertarget{rcopy}{}
\newpage
\section{FileNotFoundException}
\includegraphics[width =5in]{22.jpg}
\hypertarget{rerror}{} Java异常处理机制可以处理Exception，但是对Error却无能为力(例如资源耗尽等。。。)，出现Error JVM应当终止程序。 \hyperlink{error}{view sample}

\textbf{Java提供的是异常处理的抓抛模型。}当程序运行出现异常时JVM会自动生成相应的异常类对象，该对象被提交给Java运行时系统，这个过程称为\textbf{抛出(throw)异常}。如果一个方法内抛出异常，该异常会被抛到调用方法中。如果异常没有在调用方法中处理，它继续被抛给这个调用方法的调用者。这一过程被称为\textbf{捕获(catch)异常。}\par
捕捉文件没有发现异常可以使用try...catch...finally 语句，有时也会使用throw和throws，也可以自己定义异常，一般自己定义的异常抛出的都是Runtimerror异常类。


文件找不到异常属于一种运行时异常，下面进行测试，分为处理异常和不处理异常两种情况。\hypertarget{ex}{}\par


处理异常：\ \ \hyperlink{code1}{\textbf{view code}} \par

不处理异常：\ \ \hyperlink{code2}{\textbf{view code}}\par

\section{Code}
\subsection{code1}\hypertarget{code1}{}\hyperlink{ex}{返回}
\begin{lstlisting}
import java.io.*;
public class TestException {
    public static void main(String[] args){
	InputStream is = null;
	try {
	    is = new FileInputStream("test.txt");
	    byte [] buffer = new byte [is.available()];
	    is.read(buffer);
	    System.out.println(new String(buffer));
	} catch (IOException e) {
   	    e.printStackTrace();
	}
	System.out.println("is running");
	if(is != null) is.close();
    }
}
\end{lstlisting}\newpage
\subsection{code2}\hypertarget{code2}{}\hyperlink{ex}{返回}
\begin{lstlisting}
import java.io.*;
public class TestException {
    public static void main(String[] args){
	InputStream is = null;
	is = new FileInputStream("test.txt");
	byte [] buffer = new byte [is.available()];
	is.read(buffer);
	System.out.println(new String(buffer));
	System.out.println("is running");
	if(is != null) is.close();
}
\end{lstlisting}
\subsection{TestError}\hypertarget{error}{}\hyperlink{rerror}{返回}
\begin{lstlisting}
public class Test {
    public static void main(String[] args) {
      main(args); 
      System.out.println("testing error...");
   }
}
\end{lstlisting}
\newpage
\subsection{code3}\hypertarget{copy}{}\hyperlink{rcopy}{返回}
\begin{lstlisting}
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
public class CP{
 public static void main(String[] args){
  try{
     InputStream is = new FileInputStream(args[0]);
     OutputStream os = new FileOutputStream(args[1]);
     byte [] buffer = new byte [is.available()];
     is.read(buffer);
     os.write(buffer);	
   }catch (IOException e){
     e.printStackTrace();    
   }
   if(is != null) is.close();
   if(os != null) os.close();
 }
}
\end{lstlisting}



\newpage
\hypertarget{File}{}\subsection{File类常用函数}\hyperlink{FileOt}{返回}
\begin{lstlisting}
//构造器
public File(String filename);

//访问文件名
public String getName();
public String getPath();
public File getAbsoluteFile();
public String getAbsolutePath();
public String getParent();
public boolean renameTo(File newName);

//文件检测
public boolean exist();
public boolean canWrite();
public boolean canRead();
public boolean isFile();
public boolean isDirectory();

//文件操作相关
public boolean createNewFile();
public boolean delete();

//目录操作相关
public boolean mkｄir();
public String[] list();
public File[] listFiles();

\end{lstlisting}

\hypertarget{testfile}{}\subsection{TestFile}\hyperlink{rfile}{返回}
\begin{lstlisting}
import java.io.File;
public class TestFile {
 public static void main(String[] args) {
	File file = new File("test.txt");
	System.out.println("begin check 
	   file test.txt...");
	System.out.println("exist ? : "
	 + file.exists());
	try {
		System.out.println("success create ? :"
		 + file.createNewFile());
	} catch (Exception e) {
		System.out.println(e.getMessage());
	} 
	System.out.println("exist ? : " 
	+ file.exists());
	System.out.println("isFile ? : " 
	+ file.isFile());
	System.out.println("path: " 
	+ file.getPath());
	System.out.println("absolutePath: " 
	+ file.getAbsolutePath());
	System.out.println("success delete ? : " 
	+ file.delete());
	System.out.println("\nOK : begin check 
	  directory newfolder...");
	file = new File("newfolder");
	System.out.println("exist ? : " 
	+ file.exists());
	System.out.println("success create ? :" 
	+ file.mkdir());
	System.out.println("exist ? : " 
	+ file.exists());
        System.out.println("isDiretory ? : "
        + file.isDirectory());
        System.out.println("path: " 
        + file.getPath());
        System.out.println("absolutePath: " 
        + file.getAbsolutePath());
        System.out.println("success delete ? : "
        + file.delete());
    }
}

\end{lstlisting}


\end{CJK}
\end{document}







