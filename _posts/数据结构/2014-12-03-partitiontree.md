---
title: 划分树(静态区间第K大)
layout: post
category: 数据结构
tags: 划分树
---


###简介



这段时间一直在搞数据结构方面的内容(事实上效率很低。。。)，划分树是去年学的，到现在也快忘了，于是再捡一遍，也理解的更明白了，写出来记录下。有人说学这些数据结构没用？在我看来，这些都是基础，重在思想，不能好高骛远啊，学东西也不能那么功利吧，况且这么神奇高级的东西怎么能不学一学呢。

对于区间第K大问题，如果只有一次的询问，我们有O(n)时间复杂度的算法([点此](/code/kth.cc)获取该算法源代码)，然而此算法会破坏原序列的顺序，且无法多次支持查询。因此我们需要一种新的数据结构，所以划分树出现了。

划分树是一种求静态区间第K大数（给定一个区间[l,r],求第K大的数是多少）的一种数据结构，在O(nlogn)的预处理后，**可以在O(logn)的时间内回答一个询问**。划分树是基于线段树和快排的思想的（网上有人说有归并排序的思想，不过我没感觉到）。


###建树



对于一个区间[l,r]，设它的中位数为a[mid]，我们把小于或等于a[mid]的数都放到左子树中，大于或等于a[mid]的数放到右子树中，可以看出这明显是快速排序的核心思想。同时记录从[l,i]中有多少个数被划入了左子树中，这一步可以利用动态规划在O(n)时间内求出，这个信息主要作用是查询的时候我们会用到。
然后再递归处理左右区间，直到区间长度为1。

划分的时候我们一定要保证同一个子树中的元素顺序要和原序列顺序一致，这一点非常重要，它保证了算法的正确性（下面我会解释）。

可以看出树建完之后，中序遍历这颗线段树得到的是一个有序序列，也就是这颗树的最下层（叶节点）是有序的。这和归并排序产生的归并树有着巨大区别，归并树在最下层是原序列，是无序的，直到回溯到最上层才得到有序序列，二者正好相反，一个自顶向下，一个自底向上。



###查找



大概的思想是这样的：根据建树过程知，**左子树中的数不大于右子树中的数**。在一个大区间[L,R]中回答一个区间[l,r]的第k大数时，若这个区间中有大于等于k个数被划到了左子树，显然答案在左子树中，于是进入左子树查询，否则进入右子树查询，直到被查询的区间长度减小到1，这就得到了答案。

**下面是重点：**

说的简单，我们到底怎么查？进入左右子树时，新的查询范围又是多少？这就是划分树的关键点所在了：

>为了描述方便我们设cnt(x) = 区间[L,x]内被划到当前区间左子树中的数的个数，mid = (L + R)/2。看，之前记录的信息有用了吧。

>下面讨论中我没处理边界情况，只需要判断下就行，不影响讨论。

>1.若应进入左子树：我们需要知道区间[l,r]有多少数划到了左子树（设len1），还要知道区间[L,l-1]内有多少数划到了左子树（设len2）。显然有：en1 = cnt(r) - cnt(l-1)，len2 = cnt(l-1) - cnt(L)，因此新的查找区间就是[L + len2,L + len1 + len2 - 1]，k不变，仍是新区间的第k大数。

>2.若进入右子树：我们需要知道区间[l,r]有多少数划到了右子树（设len3），还要知道区间[L,l-1]内有多少数划到了右子树（设len4）。我们有:len3 = (r - l + 1) - len1，len4 = (l - L) - len2，因此新的查询区间就是[mid + len4 + 1,mid + len3 + len4]，此时k = k - len1，因为已有len1个数放到了左子树，就相当于在新区间中查找第k - len1大数。


上面之所以在确定新区间是可以进行加减等运算而不出错，就是因为我们在建树时保证了同一个子树中的元素顺序和原序列顺序一致，自己想想为什么是这样。


###复杂度分析



>时间复杂度：为了快速确定任意一个区间的中位数我们需要预处理数对原数组排序，花费O(nlogn)时间，建树过程每次递归都有O(n)的划分操作，根据主定理，这一步的复杂度也是O(nlogn)，因此预处理复杂度是O(nlogn)。查询是每次至少使当前区间长度减少一半，直到减少到1，因此复杂度是O(logn)，也就是树的高度。若有m个询问，那么总的时间复杂度就是O(nlogn + mlogn)。

>空间复杂度：由于要保存每层的值和记录多少数划到左子树，每层n个数，因此空间复杂度就是O(nlogn)。



###具体实现



####建树

```cpp
/*
* val[][]保存每层的值;
* dp[][]保存有多少数划到左区间;
*/

void build(int l,int r,int d){
    if(l == r) return;
    int mid = (l + r) >> 1;
    int res = mid - l + 1;
    int lpos = l,rpos = mid + 1;
    for(int i = l;i <= r;i ++) res-=(val[d][i]<ord[mid]);
    for(int i = l;i <= r;i ++){
        if(i == l) dp[d][i] == 0;
        else dp[d][i] = dp[d][i-1];
        if(val[d][i] < ord[mid]){
            dp[d][i] ++;
            val[d+1][lpos++] = val[d][i];
        }else if(val[d][i] > ord[mid]){
            val[d+1][rpos++] = val[d][i];
        }else{
            if(res){
                dp[d][i] ++;
                val[d+1][lpos++] = val[d][i];
                res --;
            }else val[d+1][rpos++] = val[d][i];
        }
    }
    build(l,mid,d+1),build(mid+1,r,d+1);
}
```



####查询

```cpp
int query(int L,int R,int l,int r,int d,int k){
    if(l == r) return val[d][l];
    int mid = (L + R) >> 1;
    int len1 = (l == L ? 0 : dp[d][l-1]);
    int len2 = dp[d][r] - len1;
    if(len2 >= k)
        return query(L,mid,L+len1,L+len1+len2-1,d+1,k);
    else {
        int len3 = (l - L) - len1;
        int len4 = (r - l + 1) - len2;
        return query(mid+1,R,mid+len3+1,mid+len3+len4,d+1,k-len2);
    }
}
```
