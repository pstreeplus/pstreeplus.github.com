---
title: IP：生成排列
layout: post
category: 读书笔记
tags: 组合数学
---

组合数学中提供了一种生成{1, 2, 3, ..., n}的排列的算法，下面不加证明的给出该算法的描述：

> 1. 找到最大的可移动整数m.
> 2. 交换m和其指向的数以及它们的指向.
> 3. 反转大于m的数的指向.

初始时赋予每个数一个方向，指向左，如果某个数大于它所指向的数，那么认为此数是可移动数。

这种方法可以生成n的所有排列，没有使用递归算法，也不需要生成排列树，作为一种生成排列的方法，值得一学。

下面给出该算法的python实现：

```python
#!/bin/env python
# -*- coding: utf-8 -*-

class Permutation(object):
    def __init__(self, n):
        self.n = n
        self.direction = [-1 for i in xrange(n)]
        self.cur_permutation = \
            [i for i in xrange(1, n+1)]
        self.has_next_permutation = True

    def next_permutation(self):
        max_m = -1
        pos_m = -1
        swap_m = -1
        for i, value in enumerate(self.cur_permutation):
            comp_pos = self.direction[i] + i
            if comp_pos < 0 or comp_pos >= self.n:
                continue
            if value < self.cur_permutation[comp_pos]:
                continue
            if max_m < value:
                pos_m = i
                max_m = value
                swap_m = comp_pos
        if max_m is -1:
            return False
        tmp = self.cur_permutation[pos_m]
        self.cur_permutation[pos_m] = self.cur_permutation[swap_m]
        self.cur_permutation[swap_m] = tmp
        tmp = self.direction[pos_m]
        self.direction[pos_m] = self.direction[swap_m]
        self.direction[swap_m] = tmp
        for i, value in enumerate(self.cur_permutation):
            if value > max_m:
                if self.direction[i] == 1:
                    self.direction[i] = -1
                else:
                    self.direction[i] = 1
        return True

    def get_next_permutation(self):
        if not self.has_next_permutation:
            return []
        ret = self.cur_permutation[:]
        self.has_next_permutation = \
            self.next_permutation()
        return ret


"""test"""
if __name__ == '__main__':
    tmp = Permutation(int(raw_input()))
    while True:
        ret = tmp.get_next_permutation()
        if not ret:
            break
        for value in ret:
            print value,
            pass
        print
```
