---
layout: post
title: Ajax学习笔记
category: 编程语言 
tags: ajax
---

##Ajax

###简介

Ajax是对Asynchronous JavaScript + XML的缩写，这一技术能够向服务器请求额外的数据而不需要重新加载页面，会带来更好的用户体验，它改变自从web诞生以来就一直沿用的“单击、等待”的交互模式。

Ajax的核心对象是XMLHttpRequest对象(简称XHR)，在XHR出现以前，Ajax式的通信必须借助一些hack手段来实现，大多数使用隐藏的框架或者内嵌框架。XHR为向服务器发送请求和解析服务器响应提供了流畅的接口，能够以异步的方式从服务器获取更多信息，也就意味着，用户单击后，不必刷新页面就能获取到新数据。虽然名字中包含XML的成分，但是Ajax通信与数据格式无关，所以从服务器接受到得数据未必是XML数据。

###XMLHttpRequest对象

####创建XHR

>```js
var xhr = new XMLHttpRequest();
```

>但是以上代码在IE7以前的版本中不支持，因为IE7之前使用的是MSXML库中的一个`ActiveX`对象实现的，在IE7之前的版本中会遇到三种不同版本的XMLHttpRequest对象，即`MSXML2.XMLHttp`、`MSXML2.XMLHttp.3.0`、`MSXML2.XMLHttp.6.0`。要想兼容IE7之前的版本，可以使用下面的函数:

>>```js
function createXHR(){
    if(typeof XMLHttpRequest != 'undefined'){
        return new XMLHttpRequest();
    }else if(typeof ActiveXObject != 'undefined'){
        var version = ['MSXML2.XMLHttp', 'MSXML2.XMLHttp.3.0', 'MSXML2.XMLHttp.6.0'];
        for(var i = 0; i < version.length; ++i){
            try{
                new ActiveXObject(version[i]);
                arguments.callee.activeXString = version[i];
                break;
            }catch(ex){
                ;
            }
        }
        return new ActiveXObject(arguments.callee.activeXString);
    }else{
        throw new Error('No XHR Object Avaliable.');
    }
}
```

####XHR的用法
>创建完XHR之后

>>1. 绑定`onreadystatechange`函数

>>2. 然后调用`open`, 初始化

>>3. 调用`send`，发起请求

>>正确的做法是在`open`调用之前就绑定`onreadystatechange`。

>XHR对象有如下常用的属性:

>>1. `responseText` : 响应主体返回的文本

>>2. `responseXML` : 如果响应的内容类型是`text/xml`或者`application/xml`，这个属性将会保持响应数据的`XML DOM`文档

>>3. `status` : HTTP状态码

>>4. `statusText` : HTTP状态码的说明文本

>>5. `readyState` : xhr请求的活动状态

>>>`0` : 未初始化，尚未调用`open`

>>>`1` : 启动，一调用`open`，但未调用`send`

>>>`2` : 发送，已经调用`send`，但尚未收到响应

>>>`3` : 接收，已经接受部分数据

>>>`4` : 完成，已经接收到所有响应的数据，可以在客户端使用了

>>>```js
var xhr = createXHR();
xhr.onreadystatechange = function() {
    if(xhr.readyState == 4){
        if((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304){  //正常状态
            alert(xhr.responseText);
        }else{
            alert('Requeset Failed: ' + xhr.status);
        }
    }
}
xhr.open('get', 'test.php', true); //true表示异步，false表示同步
xhr.send(null);
```

>>在收到响应之前可以调用`abort`方法取消异步请求

>>>```js
xhr.abort();
```

>>调用这个方法后，xhr对象会停止触发事件，而且不再允许任何与响应有关的对象属性。


###Get请求
>`GET`请求是最常见的请求类型，用于向服务器查询某些信息。通常可以在URL后面加上查询的参数。对于XHR，传入`open`方法的查询字符串必须经过正确的编码才行。每个参数的名称和值必须使用`encodeURIComponent()`进行编码，才能放在URL后面，所有的`名-值对`使用`&`连接，比如`http://xxx.com?a=1&b=2`

>>```js
function addURLParam(url, name, value){
    url += (url.indexOf(?) == -1 ? '?' : '&');
    url += encodeURIComponent(name) + '=' + encodeURIComponent(value); //对查询参数编码
    return url;
}
var url = 'test.php';
url = addURLParam(url, 'date', '2016-01-11');
url = addURLParam(url, 'key_word', '流量');
```  

###Post请求
>`POST`请求将请求参数放在请求报文的主体中，因此`POST`请求可以向服务器发送比较多的查询数据，**而且格式不限**，而`GET`请求是将请求的参数放在了请求报文的起始行的url中，而url得长度是有限制的，因此`GET`请求的参数长度是有限制的。默认情况下，服务器对POST请求和提交web表单的请求不会一视同仁，因此。服务器必须有程序来读取发送过来的数据，并从重解析出有用的部分，不过，我们可以使用XHR来模仿表单提交时的内容类型，然后以适当的方式创建一个字符串。          

>>```js
var xhr = createXHR();
xhr.onreadystatechange = function () {
    if(xhr.readyState == 4){
        if((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304){  //正常状态
            alert(xhr.responseText);
        }else{
            alert('Requeset Failed: ' + xhr.status);
    }
}
xhr.open('post', 'test.php', true);
xhr.setRequesetHeader('Content-Type', 'application/x-www-form-urlencoded'); //设置请求报文的头部信息
xhr.send('date=2016-01-11&key_word=流量');
```

##CORS
