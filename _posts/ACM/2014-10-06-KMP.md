---
layout: post
title: KMP(字符串单模式匹配算法)
category: ACM
tags: 字符串
keywords:
description:
---

###说明

关于KMP算法，网上资料很多，但讲明白的似乎并不是很多（可能是我理解能力有问题。。。），事实上在一年前我就接触KMP算法，并尝试用它解决了一些ACM题目，今天写这篇文章就是谈谈我对KMP的理解，让大家对KMP算法有更清楚的认识，希望对读者有帮助。

###KMP算法简介

KMP算法是一种字符串匹配算法，以它的发明者D.E.Knuth，V.R.Pratt，J.H.Morris命名。该算法主要功能是:给定字符串T和P,判断P是否是T的一个子串（关于子串请参照[这里](http://baike.baidu.com/view/3488712.htm?fr=aladdin)）

###朴素的匹配算法

朴素的匹配算法就是暴力枚举T的所有子串与P进行比较，容易看出这种方法在最坏情况下复杂度为**O(len(T)*len(P))**,(事实上在实际应用中很难达到这个复杂度，概率还是很小的)。

朴素匹配代码如下：

```cpp
#include<cstdio>
#include<cstring>
const int MAXN = 1e4 + 10;
int main(){
    char T[MAXN],P[MAXN];
    scanf("%s%s",T,P);
    int lenT = strlen(T),lenP = strlen(P),i,j;
    for(i = 0;i <= lenT - lenP;i ++){
        for(j = 0;j < lenP;j ++){
            if(T[i+j] != P[j]) break;
        }
        if(j == lenP){
            printf("Yes\n");
            return 0;
        }
    }
    printf("No\n");
    return 0;
}
```

可以发现上述算法之所以慢，是因为它没有充分利用手头已知的信息。当发现T的某个子串的字符与P中对应的字符不同时，本次“尝试”就会立即停止，但指针又会重新跳到下个子串的起始位置，这样指针就会在T上后退，就是说T的同一个字符会和P的字符比较多次。事实上，当发现T的某个子串与P不匹配时，我们已经知道它们匹配的部分是什么了，那么我们是不是可以利用这部分信息来减少无谓的比较呢？因此KMP产生了。

###KMP算法

KMP算法正是利用这个信息来减少比较的次数，从而在线性时间内完成判断。**我们能不能在不匹配的情况下，利用已知信息，使得指针在T串上不后退，而是去调整P的位置使得二者又重新匹配呢？，如果可以那么我们就可以在O(len(T) + len(P))时间复杂度内完成任务！** 现在关键要解决的就是怎么调整P的位置使得重新匹配,换句话说就是P向后倒退多少可以让T和P在此在当前指针的位置上匹配？